package com.miniblog.api.fake.comment;

import com.miniblog.api.comment.application.port.CommentRepository;
import com.miniblog.api.comment.domain.Comment;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class FakeCommentRepository implements CommentRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final Map<Long, Comment> comments = new ConcurrentHashMap<>();

    @Override
    public Optional<Comment> findById(Long id) {
        return Optional.ofNullable(comments.get(id));
    }

    @Override
    public Optional<Comment> findWithMemberById(Long id) {
        Comment comment = comments.get(id);
        return (comment != null && comment.getMember() != null) ? Optional.of(comment) : Optional.empty();
    }

    @Override
    public Comment save(Comment comment) {
        if (comment.getId() == null || comment.getId() == 0) {
            Long id = autoGeneratedId.incrementAndGet();
            Comment newComment = comment.toBuilder().id(id).build();
            comments.put(id, newComment);
            return newComment;
        } else {
            comments.put(comment.getId(), comment);
            return comment;
        }
    }

    @Override
    public void delete(Comment comment) {
        comments.remove(comment.getId());
    }

    @Override
    public void deleteAllByPostId(Long postId) {
        comments.values().removeIf(comment -> comment.getPost().getId().equals(postId));
    }

    @Override
    public void detachMemberByMemberId(Long memberId) {
        comments.replaceAll((id, comment) -> {
            if (comment.getMember() != null && comment.getMember().getId().equals(memberId)) {
                return comment.toBuilder().member(null).build();
            }
            return comment;
        });
    }

    @Override
    public void deleteAllByPostIds(List<Long> postIds) {
        comments.values().removeIf(comment -> postIds.contains(comment.getPost().getId()));
    }
}
