package com.miniblog.api.fake.member;

import com.miniblog.api.member.application.port.EmailCodeRepository;
import com.miniblog.api.member.domain.EmailCode;
import com.miniblog.api.member.domain.EmailCodeType;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

public class FakeEmailCodeRepository implements EmailCodeRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final Map<Long, EmailCode> emailCodeStore = new ConcurrentHashMap<>();

    @Override
    public Optional<EmailCode> findByEmailAndType(String email, EmailCodeType type) {
        return emailCodeStore.values().stream()
                .filter(emailCode -> emailCode.getEmail().equals(email) && emailCode.getType() == type)
                .findFirst();
    }

    @Override
    public EmailCode save(EmailCode emailCode) {
        if (emailCode.getId() == null || emailCode.getId() == 0) {
            long newId = autoGeneratedId.incrementAndGet();
            EmailCode newEmailCode = emailCode.toBuilder().id(newId).build();
            emailCodeStore.put(newId, newEmailCode);
            return newEmailCode;
        } else {
            emailCodeStore.put(emailCode.getId(), emailCode);
            return emailCode;
        }
    }

    @Override
    public void delete(EmailCode emailCode) {
        emailCodeStore.values().removeIf(ec -> ec.getEmail().equals(emailCode.getEmail()) && ec.getType() == emailCode.getType());
    }

    @Override
    public void deleteExpiredCodes(LocalDateTime now) {
        emailCodeStore.values().removeIf(emailCode -> emailCode.getExpiresDate().isBefore(now));
    }

    @Override
    public void deleteByEmailAndType(String email, EmailCodeType type) {
        emailCodeStore.values().removeIf(emailCode -> emailCode.getEmail().equals(email) && emailCode.getType() == type);
    }
}
